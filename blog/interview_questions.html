<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Basic Questions</title>
    <link rel="icon" type="image/svg+xml" href="../favicon.svg">
    <link rel="stylesheet" href="../style.css" />
</head>

<body>
    <header>
        <h1>Basic Questions</h1>
        <p><em>Published: August 2025</em></p>
    </header>

    <nav>
        <a href="../blog.html">&larr; Back to Blog</a>
    </nav>

    <main>
        <h2>Some Interview Questions</h2>
        <h3>Understanding @Component, @Service, and @Repository in Spring Boot</h3>
        <p>In Spring Boot, <code>@Component</code>, <code>@Service</code>, and <code>@Repository</code> are
            stereotypes used to define beans and their roles in the application context.</p>
        <ul>
            <li><strong>@Component:</strong> A generic stereotype for any Spring-managed component.</li>
            <li><strong>@Service:</strong> A specialization of <code>@Component</code> for service-layer beans.</li>
            <li><strong>@Repository:</strong> A specialization of <code>@Component</code> for data access objects
                (DAOs).</li>
        </ul>
        <p>Using these annotations helps in organizing the code and provides better readability and maintainability.</p>


        <h3>Handling Transaction Management in a Spring Boot Application with Multiple Data Sources</h3>
        <p>To handle transaction management in a Spring Boot application with multiple data sources, you can use
            the following approach:</p>
        <ul>
            <li>Define multiple <code>DataSource</code> beans for each database.</li>
            <li>Use <code>@Primary</code> to specify the default data source if needed.</li>
            <li>Configure <code>PlatformTransactionManager</code> for each data source.</ li>
            <li>Use <code>@Transactional</code> annotation with the appropriate transaction manager for
                methods that require transactions.</li>
        </ul>
        <p>This setup allows you to manage transactions across different databases effectively.</p>
        <h3>Difference Between Eager and Lazy Loading in Hibernate</h3>
        <p>Eager loading and lazy loading are two strategies for fetching related entities in Hibernate:</p>
        <ul>
            <li><strong>Eager Loading:</strong> Related entities are loaded immediately with the parent entity.
                This can lead to performance issues if not managed properly, especially with large datasets.</li>
            <li><strong>Lazy Loading:</strong> Related entities are loaded on-demand when accessed. This can improve
                performance by reducing initial load time but may lead to <code>LazyInitializationException</code>
                if accessed outside of a session context.</li>
        </ul>
        <p>Choosing between eager and lazy loading depends on the specific use case and performance considerations.</p>
        <h3>What is the Difference Between PUT and POST HTTP Methods?</h3>
        <p>The main differences between PUT and POST HTTP methods are:</p>
        <ul>
            <li><strong>PUT:</strong> Used to update or create a resource at a specific URL. It is idempotent,
                meaning multiple identical requests will have the same effect as a single request.</li>
            <li><strong>POST:</strong> Used to create a new resource. It is not idempotent, meaning multiple
                identical requests may result in multiple resources being created.</li>
        </ul>
        <p>In summary, use PUT for updates and POST for creating new resources.</p>
        <h3>What are Microservices, and What are the Benefits of Using Them?</h3>
        <p>Microservices are an architectural style that structures an application as a collection of small,
            independent services that communicate over well-defined APIs. Each service is responsible for a specific
            business capability.</p>
        <p>Benefits of using microservices include:</p>
        <ul>
            <li><strong>Scalability:</strong> Each service can be scaled independently based on demand.</li>
            <li><strong>Flexibility:</strong> Different services can use different technologies and frameworks.</li>
            <li><strong>Resilience:</strong> Failure in one service does not affect the entire application.</li>
            <li><strong>Faster Development:</strong> Teams can work on different services simultaneously.</li>
            <li><strong>Improved Maintainability:</strong> Smaller codebases are easier to manage and understand.</li>
        </ul>
        <p>Overall, microservices can lead to more agile and responsive development processes.</p>
        <h3>How Does Spring Boot's Auto-Configuration Work Under the Hood?</h3>
        <p>Spring Boot's auto-configuration works by using a combination of <code>@EnableAutoConfiguration</code> and
            <code>spring.factories</code> files. When the application starts, Spring Boot scans the classpath for
            available libraries and configurations.
        </p>
        <p>Based on the detected libraries, Spring Boot automatically configures beans and settings that are
            commonly used with those libraries. This is done through conditional annotations like
            <code>@ConditionalOnClass</code> and <code>@ConditionalOnMissingBean</code>.
        </p>
        <p>This mechanism allows developers to get started quickly without needing to manually configure every aspect
            of their application.</p>

        <h3>What is the Difference Between Monolithic and Microservices Architecture?</h3>
        <p>The main differences between monolithic and microservices architecture are:</p>
        <ul>
            <li><strong>Monolithic Architecture:</strong> The entire application is built as a single, unified unit.
                All components are tightly coupled, making it easier to develop initially but harder to scale and
                maintain over time.</li>
            <li><strong>Microservices Architecture:</strong> The application is divided into smaller, independent
                services that communicate over APIs. This allows for greater flexibility, scalability, and easier
                maintenance, but can introduce complexity in terms of service management and communication.</li>
        </ul>
        <p>In summary, monolithic architecture is simpler to start with, while microservices offer more long-term
            benefits for complex applications.</p>

        <h3>What Are CDN and Edge Caching?</h3>
        <p>Content Delivery Network (CDN) is a system of distributed servers that deliver web content to users based on
            their geographic location. CDNs help reduce latency and improve load times by caching content closer to the
            user.</p>
        <p>Edge caching is a technique used in CDNs where content is cached at the edge servers, which are located
            closer to the end-users. This further reduces latency and speeds up content delivery.</p>

        <p>Both CDN and edge caching are essential for optimizing web performance and enhancing user experience.</p>
        <p><b>Content Delivery Network (CDN):</b>
            A global network of servers that delivers web content (images, videos, scripts, etc.) from locations closest
            to the user.
        </p>
        <p><b>Edge Caching:</b>
            Storing copies of your content on “edge servers” near end-users so they get it faster, without waiting for
            your main server.
        </p>

        <h4>How Do They Give Users ‘Free Speed’?</h4>
        <table>
            <tr>
                <th>Feature</th>
                <th>How It Works</th>
                <th>User Benefit</th>
            </tr>
            <tr>
                <td>Geographic Proximity</td>
                <td>Content served from a local server, not a distant origin.</td>
                <td>Faster load times</td>
            </tr>
            <tr>
                <td>Reduced Latency</td>
                <td>Data travels a shorter distance.</td>
                <td>Quicker responses</td>
            </tr>
            <tr>
                <td>Offload Origin Server</td>
                <td>Edge caches handle most repeat requests.</td>
                <td>Less downtime/slowness</td>
            </tr>
            <tr>
                <td>Scalability</td>
                <td>Handles traffic spikes better.</td>
                <td>Consistent performance</td>
            </tr>
            <tr>
                <td>Automatic Optimization</td>
                <td>Many CDNs compress images/files and optimize delivery.</td>
                <td>Smooth experience</td>
            </tr>
        </table>
        <p>By using CDNs and edge caching, users experience faster load times, reduced latency, and a more reliable
            connection to web content, effectively giving them 'free speed'.</p>

        <h4>Example (How a CDN Improves Speed)</h4>
        <p>User in Dhaka visits your site.</p>
        <p>Instead of fetching images from a US server, they’re loaded from a CDN server in Bangladesh or close by.</p>
        <p>Result: Webpage loads dramatically faster!</p>

        <h2>What is clean code?</h2>
        <p>Clean code is that should not have code smell and that code should have follow design principles and pattern.
        </p>
        <h2>Machine learning vs AI Engineer</h2>
        <ul>
            <li>AI Engineer: Focuses on building and deploying AI systems that can perform tasks that typically require
                human intelligence. They work on a broader range of AI technologies, including natural language
                processing, computer vision, and robotics.</li>
            <li>Machine Learning Engineer: Specializes in designing, building, and deploying machine learning models.
                They focus on algorithms and statistical models that enable computers to learn from and make predictions
                or decisions based on data.</li>
        </ul>
    </main>

    <footer>
        &copy; 2025 Md. Rafiq
    </footer>
</body>

</html>