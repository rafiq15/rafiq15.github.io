<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Learn how to apply SOLID principles to Spring Boot applications with practical examples and best practices for better code design.">
    <meta name="keywords" content="SOLID principles, Spring Boot, Java, OOP, software design, clean code">
    <meta name="author" content="Rafiq">
    <title>Applying SOLID Principles to Spring Boot Applications</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0 auto;
            max-width: 800px;
            padding: 20px;
            background-color: #f4f4f4;
        }
        h1, h2, h3 {
            color: #333;
        }
        pre {
            background-color: #eee;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border-left: 4px solid #0066cc;
        }
        code {
            font-family: 'Courier New', Consolas, monospace;
            background-color: #f8f8f8;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        pre code {
            background-color: transparent;
            padding: 0;
        }
        p {
            margin: 10px 0;
        }
        ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        a {
            color: #0066cc;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        nav {
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <nav>
        <a href="../blog.html">&larr; Back to Blog</a>
    </nav>
    <h1>Applying SOLID Principles to Spring Boot Applications</h1>
    <p>In software development, Object-Oriented Design is really important for creating code that can be easily changed, expanded, and used again.</p>
    <p>The SOLID principles are a set of five design principles in object-oriented programming and software development that aim to create more maintainable, flexible, and scalable software. They were introduced by Robert C. Martin and are widely used as guidelines for designing clean and efficient code. Each letter in the word "SOLID" represents one of these principles:</p>
    <ul>
        <li><strong>S</strong>ingle Responsibility Principle (SRP)</li>
        <li><strong>O</strong>pen/Closed Principle (OCP)</li>
        <li><strong>L</strong>iskov's Substitution Principle (LSP)</li>
        <li><strong>I</strong>nterface Segregation Principle (ISP)</li>
        <li><strong>D</strong>ependency Inversion Principle (DIP)</li>
    </ul>
    <p>In this article, we will examine how each principle is used in the Spring Boot application.</p>

    <h2>1. Single Responsibility Principle (SRP)</h2>
    <p>Robert C. Martin describes it: <em>A class should have one, and only one, reason to change.</em></p>
    <p>The Single Responsibility Principle states that a class should have only one reason to change. Let's examine the incorrect usage in the example below.</p>
    <pre><code>
// Incorrect implementation of SRP
@RestController
@RequestMapping("/report")
public class ReportController {
    private final ReportService reportService;
    public ReportController(ReportService reportService) {
        this.reportService = reportService;
    }
    @PostMapping("/send")
    public ResponseEntity&lt;Report&gt; generateAndSendReport(@RequestParam String reportContent,
                                                        @RequestParam String to,
                                                        @RequestParam String subject) {
        String report = reportService.generateReport(reportContent);
        reportService.sendReportByEmail(report, to, subject);
        return new ResponseEntity&lt;&gt;(HttpStatus.OK);
    }
}
    </code></pre>
    <pre><code>
// Incorrect implementation of SRP
// The class is responsible for generating a report and sending email
@Service
@Slf4j
public class ReportServiceImpl implements ReportService {
    private final ReportRepository reportRepository;
    public ReportServiceImpl(ReportRepository reportRepository) {
        this.reportRepository = reportRepository;
    }
    @Override
    public String generateReport(String reportContent) {
        Report report = new Report();
        report.setReportContent(reportContent);
        return reportRepository.save(report).toString();
    }
    @Override
    public void sendReportByEmail(Long reportId, String to, String subject) {
        Report report = findReportById(reportId);
        sendEmail(report.getReportContent(), to, subject);
    }
    private Report findReportById(Long reportId) {
        return reportRepository.findById(reportId)
                .orElseThrow(() -> new RuntimeException("Report not found"));
    }
    private void sendEmail(String content, String to, String subject) {
       log.info(content, to, subject);
    }
}
    </code></pre>
    <p>As you can see, <code>ReportService</code> has multiple responsibilities which violates Single Responsibility:</p>
    <ul>
        <li><strong>Generate Report:</strong> The class is responsible for generating a report and saving it to the repository in the <code>generateReport</code> method.</li>
        <li><strong>Send Report by Email:</strong> The class is also responsible for sending a report by email in the <code>sendReportByEmail</code> method.</li>
    </ul>
    <p>When creating code, it's important to avoid putting too many responsibilities in one place â€” whether it's a class or method. This makes the code complex and hard to maintain. It also makes it difficult to make small changes because they might affect other parts of the code, requiring comprehensive testing even for minor updates.</p>
    <p>Let's correct this implementation:</p>
    <pre><code>
@RestController
@RequestMapping("/report")
public class ReportController {
    private final ReportService reportService;
    private final EmailService emailService;
    public ReportController(ReportService reportService, EmailService emailService) {
        this.reportService = reportService;
        this.emailService = emailService;
    }
    @PostMapping("/send")
    public ResponseEntity&lt;Report&gt; generateAndSendReport(@RequestParam String reportContent,
                                                        @RequestParam String to,
                                                        @RequestParam String subject) {
        // correct impl reportService is responsible for generation
        Long reportId = Long.valueOf(reportService.generateReport(reportContent));
        // correct impl emailService is responsible for sending
        emailService.sendReportByEmail(reportId, to, subject);
        return new ResponseEntity&lt;&gt;(HttpStatus.OK);
    }
}
    </code></pre>
    <pre><code>
@Service
public class ReportServiceImpl implements ReportService {
    private final ReportRepository reportRepository;
    public ReportServiceImpl(ReportRepository reportRepository) {
        this.reportRepository = reportRepository;
    }
    @Override
    public String generateReport(String reportContent) {
        Report report = new Report();
        report.setReportContent(reportContent);
        return reportRepository.save(report).toString();
    }
}
@Service
public class EmailServiceImpl implements EmailService {
    private final ReportRepository reportRepository;
    public EmailServiceImpl(ReportRepository reportRepository) {
        this.reportRepository = reportRepository;
    }
    @Override
    public void sendReportByEmail(Long reportId, String to, String subject) {
        Report report = findReportById(reportId);
        if (ObjectUtils.isEmpty(report) || !StringUtils.hasLength(report.getReportContent())) {
            throw new RuntimeException("Report or report content is empty");
        }
    }
    private Report findReportById(Long reportId) {
        return reportRepository.findById(reportId)
                .orElseThrow(() -> new RuntimeException("Report not found"));
    }
}
    </code></pre>
    <p>The refactored code includes changes below:</p>
    <ul>
        <li><code>ReportServiceImpl</code> is responsible for generating reports.</li>
        <li><code>EmailServiceImpl</code> is responsible for sending reports - that were generated by <code>ReportServiceImpl</code> - by email.</li>
        <li>The <code>ReportController</code> manages the process of generating and sending reports by using the appropriate services.</li>
    </ul>

    <h2>2. Open/Closed Principle (OCP)</h2>
    <p>The Open-Closed Principle says that a class should be open for extension and closed to modification. This helps avoid introducing bugs to a working application. In simpler terms, this means that you should be able to add new functionality to a class without changing its existing code.</p>
    <p>Let's examine the incorrect usage in the example below.</p>
    <pre><code>
// Incorrect implementation violating OCP
public class ReportGeneratorService {
    public String generateReport(Report report) {
        if ("PDF".equals(report.getReportType())) {
            // Incorrect: Direct implementation for generating PDF report
            return "PDF report generated";
        } else if ("Excel".equals(report.getReportType())) {
            // Incorrect: Direct implementation for generating Excel report
            return "Excel report generated";
        } else {
            return "Unsupported report type";
        }
    }
}
    </code></pre>
    <p>In this incorrect implementation, the <code>generateReport</code> method of <code>ReportService</code> has conditional statements to check the report type and directly generates the report accordingly. This violates the Open-Closed Principle because if you want to add support for a new report type, you would need to modify this class.</p>
    <p>Let's correct this implementation:</p>
    <pre><code>
public interface ReportGenerator {
    String generateReport(Report report);
}
// Concrete implementation for generating PDF reports
@Component
public class PdfReportGenerator implements ReportGenerator {
    @Override
    public String generateReport(Report report) {
        // Impl of pdf report
        return String.format("PDF report generated for %s", report.getReportType());
    }
}
// Concrete implementation for generating Excel reports
@Component
public class ExcelReportGenerator implements ReportGenerator {
    @Override
    public String generateReport(Report report) {
        // Impl of excel report
        return String.format("Excel report generated for %s", report.getReportType());
    }
}
// Service that follows OCP
@Service
public class ReportGeneratorService {
    private final Map&lt;String, ReportGenerator&gt; reportGenerators;
    @Autowired
    public ReportGeneratorService(List&lt;ReportGenerator&gt; generators) {
        // Initialize the map of report generators
        this.reportGenerators = generators.stream()
                .collect(Collectors.toMap(generator -> generator.getClass().getSimpleName(), Function.identity()));
    }
    public String generateReport(Report report, String reportType) {
        return reportGenerators.getOrDefault(reportType, unsupportedReportGenerator())
                .generateReport(report);
    }
    private ReportGenerator unsupportedReportGenerator() {
        return report -> "Unsupported report type";
    }
}
    </code></pre>
    <p><strong>Interface -&gt; <code>ReportGenerator</code></strong></p>
    <ul>
        <li>Added an interface (<code>ReportGenerator</code>) to define a common method for report generation.</li>
    </ul>
    <p><strong>Concrete Implementations -&gt; <code>PdfReportGenerator</code> and <code>ExcelReportGenerator</code></strong></p>
    <ul>
        <li>Created classes implementing the interface for PDF and Excel report generation.</li>
        <li>Followed the Open-Closed principle of allowing extension without modifying existing code.</li>
    </ul>
    <p><strong>Report Generator Service -&gt; <code>ReportGeneratorService</code></strong></p>
    <ul>
        <li>Introduced a service managing different report generator implementations.</li>
        <li>Allows adding new report generators without changing existing code.</li>
    </ul>
    <p>In summary, the service handles these implementations dynamically, making it easy to add new features without changing existing code, following the Open-Closed Principle.</p>

    <h2>3. Liskov's Substitution Principle (LSP)</h2>
    <p>The Liskov Substitution Principle states that if you have a class, you should be able to replace it with a subclass without causing any problems in your program. In other words, you can use the specialized version wherever you use the more general version, and everything should still work correctly.</p>
    <p>Let's examine the incorrect usage in the example below.</p>
    <pre><code>
// Incorrect implementation violating LSP
public class Bird {
    public void fly() {
        // I can fly
    }
    public void swim() {
        // I can swim
    }
}
public class Penguin extends Bird {
    // Penguins cannot fly, but we override the fly method and throws Exception
    @Override
    public void fly() {
        throw new UnsupportedOperationException("Penguins cannot fly");
    }
}
    </code></pre>
    <p>Let's correct this implementation:</p>
    <pre><code>
// Correct implementation for LSP
public class Bird {
    // methods
}
public interface Flyable {
    void fly();
}
public interface Swimmable {
    void swim();
}
public class Penguin extends Bird implements Swimmable {
    // Penguins cannot fly, therefore we only implement swim interface
    @Override
    public void swim() {
        System.out.println("I can swim");
    }
}
public class Eagle extends Bird implements Flyable {
    @Override
    public void fly() {
        System.out.println("I can fly");
    }
}
    </code></pre>
    <ul>
        <li><code>Bird</code> class serves as a base class for birds and includes common properties or methods shared among all birds.</li>
        <li>Introduced <code>Flyable</code> and <code>Swimmable</code> interfaces to represent specific behaviors.</li>
        <li>In the <code>Penguin</code> class, implemented the <code>Swimmable</code> interface to reflect penguins' swimming ability.</li>
        <li>In the <code>Eagle</code> class, implemented the <code>Flyable</code> interface to reflect eagles' flying ability.</li>
    </ul>
    <p>By separating specific behaviors into interfaces and implementing them in subclasses, we follow the Liskov Substitution Principle, which allows us to switch subclasses without causing any unexpected issues.</p>

    <h2>4. Interface Segregation Principle (ISP)</h2>
    <p>Interface Segregation Principle states that larger interfaces should be split into smaller, more specific ones. By doing so, we can ensure that implementing classes only need to be concerned about the methods that are relevant to them.</p>
    <p>Let's examine the incorrect usage in the example below.</p>
    <pre><code>
public interface Athlete {
    void compete();
    void swim();
    void highJump();
    void longJump();
}
// Incorrect implementation violating Interface Segregation
public class JohnDoe implements Athlete {
    @Override
    public void compete() {
        System.out.println("John Doe started competing");
    }
    @Override
    public void swim() {
        System.out.println("John Doe started swimming");
    }
    @Override
    public void highJump() {
        // Not necessary for John Doe
    }
    @Override
    public void longJump() {
        // Not necessary for John Doe
    }
}
    </code></pre>
    <p>Imagine John Doe as a swimmer. He is forced to provide empty implementations for <code>highJump</code> and <code>longJump</code>, which are irrelevant to his role as a swimmer.</p>
    <p>Let's correct this implementation:</p>
    <pre><code>
public interface Athlete {
    void compete();
}
public interface JumpingAthlete {
    void highJump();
    void longJump();
}
public interface SwimmingAthlete {
    void swim();
}
// Correct implementation for Interface Segregation
public class JohnDoe implements Athlete, SwimmingAthlete {
    @Override
    public void compete() {
        System.out.println("John Doe started competing");
    }
    @Override
    public void swim() {
        System.out.println("John Doe started swimming");
    }
}
    </code></pre>
    <p>The original <code>Athlete</code> interface has been split into three separate interfaces: <code>Athlete</code> for general activities, <code>JumpingAthlete</code> for jumping-related activities, and <code>SwimmingAthlete</code> for swimming. This adheres to the Interface Segregation Principle, ensuring that a class is not forced to implement methods it does not need.</p>
    <p>This example demonstrates how to properly apply the Interface Segregation Principle in object-oriented design.</p>

    <h2>5. Dependency Inversion Principle (DIP)</h2>
    <p>The Dependency Inversion Principle (DIP) states that high-level modules should not depend on low-level modules; both should depend on abstractions. Abstractions should not depend on details.</p>
    <p>Let's examine the incorrect usage in the example below.</p>
    <pre><code>
// Incorrect implementation of Dependency Inversion Principle
@Service
public class PayPalPaymentService {
    public void processPayment(Order order) {
        // payment processing logic
    }
}
@RestController
public class PaymentController {
    // Direct dependency on a specific implementation
    private final PayPalPaymentService paymentService;
    // Constructor directly initializes a specific implementation
    public PaymentController() {
        this.paymentService = new PayPalPaymentService();
    }
    @PostMapping("/pay")
    public void pay(@RequestBody Order order) {
        paymentService.processPayment(order);
    }
}
    </code></pre>
    <p>Let's correct this implementation:</p>
    <pre><code>
// Introduced interface
public interface PaymentService {
    void processPayment(Order order);
}
// Implemented interface in a service class
@Service
public class PayPalPaymentService implements PaymentService {
    @Override
    public void processPayment(Order order) {
        // payment processing logic
    }
}
@RestController
public class PaymentController {
    private final PaymentService paymentService;
    // Constructor injection
    public PaymentController(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
    @PostMapping("/pay")
    public void pay(@RequestBody Order order) {
        paymentService.processPayment(order);
    }
}
    </code></pre>
    <ul>
        <li>Introduced the <code>PaymentService</code> interface.</li>
        <li>Injected the <code>PaymentService</code> interface into the controller's constructor in order to provide abstraction in controller.</li>
        <li>Controller depends on the abstraction (<code>PaymentService</code>), allowing for dependency injection of any class implementing the interface.</li>
    </ul>
    <p>This example demonstrates proper application of the Dependency Inversion Principle.</p>
    <p>Dependency Inversion Principle (DIP) and Dependency Injection (DI) are related concepts in the Spring Framework. DIP, introduced by Robert C. Martin (Uncle Bob), is about keeping code loosely coupled. It enables Dependency Injection in Spring, where the framework manages dependencies during runtime.</p>

    <h2>Conclusion</h2>
    <p>SOLID principles are essential in Object-Oriented Programming (OOP) because they provide a set of guidelines and best practices to design software that is more maintainable, flexible, and scalable.</p>
    <p>In this article, we started by discussing common mistakes when applying SOLID principles in Java applications. After that, we examined related examples to see how these issues can be resolved.</p>
    <p>All examples are presented at a basic level, you can refer to the provided references for further reading.</p>
    <p><a href="https://medium.com/@saygiligozde/applying-solid-principles-to-spring-boot-applications-191d7e50e1b3">Original article</a> by Gozde Saygili Yalcin</p>
</body>
</html>