<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
     <meta name="description" content="Learn Object Relational Mapping with Spring Boot, JPA and Hibernate. Understand One-to-One, One-to-Many, and Many-to-Many relationships with practical examples.">
    <meta name="keywords" content="Spring Boot, JPA, Hibernate, ORM, Object Relational Mapping, Java, Database, Relationships">
    <meta name="author" content="Rafiq">
    <title>Object Relational Mapping with Spring Boot, JPA and Hibernate</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0 auto;
            max-width: 800px;
            padding: 20px;
            background-color: #f4f4f4;
        }
        h1, h2, h3 {
            color: #333;
        }
        pre {
            background-color: #eee;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border-left: 4px solid #0066cc;
        }
        code {
            font-family: 'Courier New', Consolas, monospace;
            background-color: #f8f8f8;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        pre code {
            background-color: transparent;
            padding: 0;
        }
        p {
            margin: 10px 0;
        }
        ul, ol {
            margin: 10px 0;
            padding-left: 20px;
        }
        a {
            color: #0066cc;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        nav {
            margin-bottom: 20px;
        }
        .highlight {
            background-color: #fff3cd;
            padding: 10px;
            border-radius: 5px;
            border-left: 4px solid #ffc107;
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <nav>
        <a href="../blog.html">&larr; Back to Blog</a>
    </nav>
    <h1>Object Relational Mapping with Spring Boot, JPA and Hibernate</h1>
    <h2>Let‚Äôs deal with object relationships</h2>
    <p>Since you know about the Spring Boot framework, you may have used JPA and Hibernate when working with relational databases like MySQL or PostgreSQL. Hibernate ORM is an object‚Äìrelational mapping tool for the Java programming language. It provides a framework for mapping an object-oriented domain model to a relational database. In simpler terms, we can map Java objects to database tables! Hibernate is the default implementation of the JPA specification in Spring Boot.</p>
    <p>This framework magically enhances the codebase with more reusability and maintainability. We can link just Java objects using few annotations straightforward. According to the rules we specify, then data will be saved in the database tables.</p>
    <p>I will be using a Spring Boot application with H2 in-memory database to demonstrate the relationships practically. You can find the source code from here: <a href="https://github.com/SalithaUCSC/spring-boot-orm">https://github.com/SalithaUCSC/spring-boot-orm</a></p>
    <p>All the dependencies used are available here: <a href="https://github.com/SalithaUCSC/spring-boot-orm/blob/main/pom.xml">https://github.com/SalithaUCSC/spring-boot-orm/blob/main/pom.xml</a></p>
    <p>Let‚Äôs start with some basics‚Ä¶ üòé</p>

    <h2>Fetch Types in Hibernate</h2>
    <p><strong>EAGER:</strong> Load the associated data of the other entity beforehand, which is a bit costly.</p>
    <p><strong>LAZY:</strong> Load the associated data of the other entity only when requested. This is done on demand.</p>
    
    <p>There are specified fetching types for each relationship type which Hibernate applies by default:</p>
    <pre><code>
OneToMany: LAZY
ManyToOne: EAGER
ManyToMany: LAZY
OneToOne: EAGER
    </code></pre>
    <p><strong>Example:</strong></p>
    <p>If we have a relationship between university and student, when university data is fetched, we don‚Äôt want to fetch students right? Because, one university will have thousands of students in the students array in the mapping. It will be a very costly operation. So, we can tell Hibernate to keep it with LAZY initialization.</p>
    <p>We can decide how to do that later‚Ä¶</p>

    <h2>Cascade Types in Hibernate</h2>
    <p>In Hibernate, Cascade Types define how operations should be propagated between related entities. There are several predefined types:</p>
    <ol>
        <li><strong>CascadeType.PERSIST</strong>: Both save() or persist() operations cascade to related entities.</li>
        <li><strong>CascadeType.MERGE</strong>: Related entities are merged when the ownership entity is merged.</li>
        <li><strong>CascadeType.REFRESH</strong>: Does the same thing for the refresh() operation.</li>
        <li><strong>CascadeType.REMOVE</strong>: Removes all related entities associated with this setting when the ownership entity is deleted.</li>
        <li><strong>CascadeType.DETACH</strong>: Detaches all related entities if a ‚Äúmanual detach‚Äù occurs.</li>
        <li><strong>CascadeType.ALL</strong>: All of the above cascade operations.</li>
    </ol>
    <p>üî¥ <strong>Important:</strong> There is no default cascade type in JPA. By default, no operation is cascaded. If we want, we can use several cascade types at once:</p>
    <pre><code>
cascade = { CascadeType.PERSIST, CascadeType.MERGE, CascadeType.DETACH, CascadeType.REFRESH }
    </code></pre>
    <p>Let‚Äôs start to learn about object-relational mapping with examples. üí™</p>

    <h2>One-to-One Mapping üí•</h2>
    <p>I‚Äôm going to build up a relationship between User and Address. Any User has an address here. Two users cannot have the same Address!</p>
    <p>I don‚Äôt want the Address record without the relevant User. I think it can be the most common scenario. In a one-to-one mapping, both entities are tightly coupled. After the User is removed, we cannot use his/her Address. So I will define CascadeType as ALL (If you want to keep the Address, change it to PERSIST). Then address won‚Äôt be deleted even if we delete the user. Since Hibernate decides FetchType for one-to-one mapping is EAGER by default, I don‚Äôt want to mention it as a rule.</p>
    <p><strong>How relationship is built???</strong></p>
    <p>Normally we record the child entity primary key as the foreign key of the owner entity. So User should have a column in the table to record the address ID. I have given its name as ‚Äúaddress_id‚Äù and it‚Äôs referenced by ‚Äúid‚Äù column in Address entity.</p>
    <h3>User</h3>
    <pre><code>
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Long id;
    String name;
    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "address_id", referencedColumnName = "id")
    Address address;
}
    </code></pre>
    <h3>Address</h3>
    <pre><code>
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "addresses")
public class Address {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Long id;
    String street;
    String city;
    @JsonIgnore
    @OneToOne(mappedBy = "address")
    User user;
}
    </code></pre>
    <p>In the child entity (Address), we just need to link the name of the property mapped in User entity.</p>
    <p>‚Äú@JsonIgnore‚Äù annotation was placed there for user property since I do not need to have the user object to be seen in Address data. Just to ignore that field from JSON object.</p>
    <p>This way we can have a Bi-directional one-to-one mapping! üí™</p>

    <h2>One-to-Many Mapping üí•</h2>
    <p>I‚Äôm creating another relationship between Post and Comment entities. Any kind of post can have one or more comments. But every comment is having only one post! So, this is a one-to-many relationship exactly‚Ä¶</p>
    <p>I need to see the comments of each post while post data is fetched. That means, comments should be eagerly fetched right? That‚Äôs why I have put fetch type as EAGER for comments set. Hibernate will set fetch type as LAZY by default for one-to-many mappings. To override that, I have specifically mentioned the fetch type.</p>
    <p><strong>How relationship is built???</strong></p>
    <p>Tables should be connected in a way when the Comment table is having a column to place the primary key of the Post. That‚Äôs how we design the logical schema right‚Ä¶ I have named the column ‚Äúpost_id‚Äù in this case. You may remember ER diagrams for this as I feel now.</p>
    <h3>Post</h3>
    <pre><code>
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "posts")
public class Post {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Long id;
    String title;
    String description;
    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER)
    @JoinColumn(name = "post_id", referencedColumnName = "id")
    Set<Comment> comments = new HashSet<>();
}
    </code></pre>
    <p>When a post is deleted, comments should not be there... It‚Äôs obvious. So, we can put CascadeType as ALL.</p>
    <h3>Comment</h3>
    <pre><code>
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "comments")
public class Comment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Long id;
    String author;
    String content;
    @Column(name = "post_id")
    Long postId;
}
    </code></pre>
    <p>Comment has the owning entity primary key as described before.</p>
    <p>This way we can have a uni-directional one-to-many mapping! Actually, in one-to-many scenarios, it is often sufficient to have a uni-directional relationship. No need to be bi-directional. üí™ We just need to make sure that the primary key of the Post is inserted into the Comment object while a comment is saved.</p>

    <h2>Many-to-Many Mapping üí•</h2>
    <p>Do you have any idea how we represented a many-to-many relationship in our logical design (ER diagram)?? This is a very special scenario, where we need an additional table more than the two entities.</p>
    <p>Let me take an example and explain. In an Employee management system, every employee has one or more Role. Any employee can have one or more roles and any role can have one or more employees! Then that is many-to-many right?</p>
    <p><strong>How relationship is built???</strong></p>
    <p>Here, we have to record which employee has which role‚Ä¶ That‚Äôs the need for the 3rd table! Simply we can save ‚Äúemployee_id‚Äù and ‚Äúrole_id‚Äù to keep the employee and role associations. If there are any other related things specific to this association, we can reserve more columns in the same table.</p>
    <h3>Employee</h3>
    <pre><code>
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "employees")
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Long id;
    String name;
    String email;
    @ManyToMany(fetch = FetchType.EAGER, cascade = CascadeType.ALL)
    @JoinTable(
        name = "employee_roles",
        joinColumns = @JoinColumn(
            name = "employee_id", referencedColumnName = "id"
        ),
        inverseJoinColumns = @JoinColumn(
            name = "role_id", referencedColumnName = "id"
        )
    )
    Set<Role> roles = new HashSet<>();
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Employee employee = (Employee) o;
        return id.equals(employee.id) && name.equals(employee.name) && email.equals(employee.email);
    }
    @Override
    public int hashCode() {
        return Objects.hash(id, name, email);
    }
}
    </code></pre>
    <p>Employee is the owning entity in the relationship. So, it‚Äôs annotated with ‚Äú@ManyToMany‚Äù. We have to place join table config here. So, ‚Äú@JoinTable‚Äù annotation represents this new table with name as ‚Äúemployee_roles‚Äù. There we have to give the two columns we use for the associations. They are primary keys in employees and roles tables.</p>
    <p>I need to show the user roles when user data is retrieved. Since Hibernate considers LAZY as the default fetch type for ManyToMany mappings, I had to set up EAGER fetch there.</p>
    <h3>Role</h3>
    <pre><code>
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "roles")
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Long id;
    String name;
    @ManyToMany(mappedBy = "roles")
    @JsonIgnore
    Set<Employee> employees = new HashSet<>();
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Role role = (Role) o;
        return id.equals(role.id) && name.equals(role.name);
    }
    @Override
    public int hashCode() {
        return Objects.hash(id, name);
    }
}
    </code></pre>
    <p>In the child entity, we just need to link the name of the property mapped in User entity.</p>
    <p>‚Äú@JsonIgnore‚Äù annotation was placed there for employees property since I do not need to have the employee object to be seen in Role data.</p>
    <p>This way we can establish a bi-directional many-to-many mapping! üí™</p>
    <p>How data is saved in the 3rd table in our in-memory database is shown below, for this scenario.</p>
    <p>When we fetch employees, it will give the result as expected.</p>
    <p>That‚Äôs all guys! All the common relationship scenarios have been explained! üòç According to the setup, uni or bi-directional mappings can be there. I have taken some real-world examples and tried to explain them all with code. We should always think from the aspect of real-world entities and how they practically exist. Then our lives will be easier while coding!!!</p>
    <p>I hope you may get the idea and try to use ORM techniques while your day-to-day object-oriented programming. üí™</p>
    <p>Bye bye ‚ù§Ô∏è</p>
    <p><a href="https://salithachathuranga94.medium.com/object-relational-mapping-with-spring-boot-jpa-and-hibernate-18cdfc51b4f0">Original article</a> by Salitha Chathuranga</p>
    <h2>Written by Salitha Chathuranga</h2>
    <p>Technical Lead at Sysco LABS | Senior Java Developer | Blogger</p>
</body>
</html>